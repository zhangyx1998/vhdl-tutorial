import{_ as e,c as t,o as i,a as o}from"./app.2ca36a0f.js";const f=JSON.parse('{"title":"VHDL Tutorial by Greg Stitt","description":"","frontmatter":{},"headers":[{"level":2,"title":"Introduction","slug":"introduction","link":"#introduction","children":[]},{"level":2,"title":"Methodology: design the circuit, then write the code.","slug":"methodology-design-the-circuit-then-write-the-code","link":"#methodology-design-the-circuit-then-write-the-code","children":[]},{"level":2,"title":"VHDL vs. Verilog vs. SystemVerilog","slug":"vhdl-vs-verilog-vs-systemverilog","link":"#vhdl-vs-verilog-vs-systemverilog","children":[]},{"level":2,"title":"Suggested Study Order","slug":"suggested-study-order","link":"#suggested-study-order","children":[]}],"relativePath":"index.md"}'),a={name:"index.md"},s=o('<h1 id="vhdl-tutorial-by-greg-stitt" tabindex="-1">VHDL Tutorial <sup style="font-size:0.5em;">by <a href="//www.gstitt.ece.ufl.edu/" target="_blank"><code>Greg Stitt</code></a></sup> <a class="header-anchor" href="#vhdl-tutorial-by-greg-stitt" aria-hidden="true">#</a></h1><h2 id="introduction" tabindex="-1">Introduction <a class="header-anchor" href="#introduction" aria-hidden="true">#</a></h2><p>This repository provides a tutorial on how to write synthesizable <code>VHDL</code> code. It touches on verification topics, but the primary focus is on code for synthesis. Most of the provided examples include multiple implementations that illustrate common mistakes, different ways of implementing the same circuit, or different tradeoffs.</p><p>This tutorial teaches the <em><strong>1993 VHDL standard</strong></em> due its widespread support. When appropriate, the tutorial will point out key differences in the 2008 and 2019 standards.</p><div class="tip custom-block"><p class="custom-block-title">Prerequisites</p><p>This tutorial assumes you already have a background in digital logic, synthesis tools, and simulators. All examples have been tested in Quartus and ModelSim, for which there are free versions available for students.</p></div><h2 id="methodology-design-the-circuit-then-write-the-code" tabindex="-1">Methodology: design the circuit, then write the code. <a class="header-anchor" href="#methodology-design-the-circuit-then-write-the-code" aria-hidden="true">#</a></h2><p>My biggest suggestion for writing synthesizable code in any language is to design the circuit, then write the code. Basically, you should be able to hierarchically divide a large circuit into smaller and smaller components, until each component is either combinational logic, sequential logic, a combination of both (e.g., a datapath), finite state machines, or memories. Then, you can simply follow the following synthesis guidelines for each of these types of circuits. Note that some of the guidelines contradict each other if used for the wrong type of logic, which is why it is always important to know the type of logic that you are designing. In other words, don&#39;t start writing the code until you know what type of circuit you are describing. If you are creating a structural archiecture, draw the schematic first. If you are designing a state machine, draw the FSM first. If you are designing a circuit with registers, first figure out exactly where you want registers, etc.</p><h2 id="vhdl-vs-verilog-vs-systemverilog" tabindex="-1"><code>VHDL</code> vs. <code>Verilog</code> vs. <code>SystemVerilog</code> <a class="header-anchor" href="#vhdl-vs-verilog-vs-systemverilog" aria-hidden="true">#</a></h2><p>I am frequently asked which RTL language is &quot;best,&quot; or why I prefer one over another. Personally, if I was forced to pick one language, I would choose <code>SystemVerilog</code>. However, this comes with many disclaimers. <code>Verilog</code> and <code>SystemVerilog</code> (which I&#39;ll refer to collectively as <code>Verilog</code> for simplicity) are often preferred due to more convenient syntax than <code>VHDL</code>, and due to <code>Verilog</code> automatically doing certain things for you (e.g., converting widths automatically). However, the convenience of <code>Verilog</code> doing things for you means in many cases it will do things you did not intend. I frequently have mistakes in my <code>Verilog</code> code that I&#39;m shocked actually compile without warnings. In many cases, identifying these problems is a very time consuming process. Even worse, some of these issues can lead to the dreaded situation of a design working in simulation but not after synthesis. Since these types of problems can take an indefinite amount of time to debug, I strongly prefer <code>VHDL</code> as the initial RTL language that people should learn. <code>VHDL</code> will catch the vast majority of these problems at compile time and does not require learning numerous problematic uses of common constructs (e.g. race conditions from blocking assignments). Once a designer has significant experience creating synthesizable code, it then becomes safer to switch to <code>Verilog</code>. I have had many students hired into <code>Verilog</code> jobs only knowing <code>VHDL</code>, and they have excelled.</p><p>One other issue to realize is that most <code>VHDL</code> code is written for the 1993 standard. Many of the annoyances of <code>VHDL</code> are limited to that standard and have been addressed by the 2008 and 2019 standards. However, those versions do not have widespread tool support, which is unfortunate because if you want to write <code>VHDL</code> that will work anywhere, it probably needs to use the 1993 standard.</p><h2 id="suggested-study-order" tabindex="-1">Suggested Study Order <a class="header-anchor" href="#suggested-study-order" aria-hidden="true">#</a></h2><ol><li><a href="./combinational/README.html">Combinational Logic</a></li><li><a href="./structural/README.html">Structural Architectures</a></li><li><a href="./sequential/README.html">Sequential Logic</a></li><li><a href="./fsm/README.html">Finite-State Machines</a></li><li><a href="./fsmd/README.html">Finite-State Machines + Datapaths</a></li><li><a href="./.html">Misc (TBD)</a></li><li><a href="./.html">Testbenches (TBD)</a></li></ol>',12),r=[s];function n(d,c,l,h,u,g){return i(),t("div",null,r)}const y=e(a,[["render",n]]);export{f as __pageData,y as default};
